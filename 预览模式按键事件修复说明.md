# 预览模式按键事件修复说明

**修复时间**: 2026-01-27
**问题**: AI 生成的 WASD 控制积木在预览模式下无法工作

## 问题根源

预览模式中按键事件无法触发积木执行，是由于**两个关键的命名不匹配**：

### 问题 1：触发器键名不匹配

**症状**：AI 生成了 `event_keypress` 积木，但预览时按键没有反应

**原因**：
- **保存时**：RightSidebar.tsx 第259行将积木保存到 `scripts['keydown']`
- **查找时**：GameEngine.ts 第412行查找 `trigger === 'onKeyDown'`
- **结果**：`'keydown'` ≠ `'onKeyDown'`，导致积木无法被找到和执行

**修复前**：
```typescript
// RightSidebar.tsx 第259行
triggerKey = 'keydown';  // ❌ 小写

// GameEngine.ts 第412行
.filter((s) => s.enabled && s.trigger === 'onKeyDown')  // ❌ 驼峰命名
```

**修复后**：
```typescript
// RightSidebar.tsx 第259行
triggerKey = 'onKeyDown';  // ✅ 统一使用驼峰命名

// GameEngine.ts 第412行（无需修改）
.filter((s) => s.enabled && s.trigger === 'onKeyDown')  // ✅ 驼峰命名
```

### 问题 2：按键值格式不匹配

**症状**：积木被找到了，但按键判断逻辑不工作

**原因**：
- **传入值**：GamePreview.tsx 第160行传入小写字母 `'w'`, `'a'`, `'s'`, `'d'`
- **期望值**：积木定义中的按键值是 `'KeyW'`, `'KeyA'`, `'KeyS'`, `'KeyD'`
- **结果**：`'w'` ≠ `'KeyW'`，导致按键匹配失败

**修复前**：
```typescript
// GamePreview.tsx 第160行
engineRef.current.handleKeyDown(key);  // ❌ 传入 'w'

// 积木参数值期望：'KeyW'
```

**修复后**：
```typescript
// GamePreview.tsx 第160行
const keyCode = 'Key' + key.toUpperCase();  // 'w' → 'KeyW'
engineRef.current.handleKeyDown(keyCode);  // ✅ 传入 'KeyW'
```

## 修复内容

### 1. 统一触发器命名（RightSidebar.tsx）

修改了 `handleAIBlocksGenerated` 函数，将所有触发器键名改为驼峰命名：

| 旧键名（错误） | 新键名（正确） | 说明 |
|--------------|--------------|------|
| `'keydown'` | `'onKeyDown'` | 按键按下事件 |
| `'tap'` | `'onClick'` | 点击事件 |
| `'collision'` | `'onCollision'` | 碰撞事件 |
| - | `'onGameStart'` | 场景初始化（新增）|

**修改位置**：`src/components/layout/RightSidebar.tsx` 第252-283行

**关键代码**：
```typescript
// 按键相关积木
if (block.type === 'event_keypress' || ...) {
  triggerKey = 'onKeyDown';  // 使用引擎期望的驼峰命名
  break;
}

// 点击相关积木
else if (block.type === 'event_click' || ...) {
  triggerKey = 'onClick';  // 使用驼峰命名
  break;
}

// 碰撞相关积木
else if (block.type === 'event_collision' || ...) {
  triggerKey = 'onCollision';  // 使用驼峰命名
  break;
}

// 场景初始化（新增）
else if (block.type === 'event_sceneinit' || block.type === 'game_event_start') {
  triggerKey = 'onGameStart';  // 使用驼峰命名
  break;
}
```

### 2. 修复按键值格式（GamePreview.tsx）

修改了键盘事件处理，将按键转换为标准格式：

**修改位置**：`src/components/preview/GamePreview.tsx` 第150-185行

**修复前**：
```typescript
const handleKeyDown = (e: KeyboardEvent) => {
  const key = e.key.toLowerCase();  // 'w'
  if (['w', 'a', 's', 'd'].includes(key)) {
    engineRef.current.handleKeyDown(key);  // ❌ 传入 'w'
  }
};
```

**修复后**：
```typescript
const handleKeyDown = (e: KeyboardEvent) => {
  const key = e.key.toLowerCase();  // 'w'
  if (['w', 'a', 's', 'd'].includes(key)) {
    const keyCode = 'Key' + key.toUpperCase();  // 'w' → 'KeyW'
    engineRef.current.handleKeyDown(keyCode);  // ✅ 传入 'KeyW'
  }
  // 处理空格键
  else if (e.key === ' ') {
    engineRef.current.handleKeyDown('Space');  // ✅ 空格键
  }
  // 处理方向键
  else if (e.key.startsWith('Arrow')) {
    engineRef.current.handleKeyDown(e.key);  // ✅ ArrowUp 等
  }
};
```

**支持的按键格式**：
- WASD: `'KeyW'`, `'KeyA'`, `'KeyS'`, `'KeyD'`
- 空格: `'Space'`
- 方向键: `'ArrowUp'`, `'ArrowDown'`, `'ArrowLeft'`, `'ArrowRight'`

## 工作流程图

### 修复前（不工作）

```
AI生成积木
  ↓
保存到 scripts['keydown']  ❌
  ↓
预览时查找 trigger === 'onKeyDown'  ❌
  ↓
找不到积木 → 没有反应
```

```
按下 W 键
  ↓
传入 'w'  ❌
  ↓
积木期望 'KeyW'  ❌
  ↓
按键不匹配 → 没有反应
```

### 修复后（正常工作）

```
AI生成积木
  ↓
保存到 scripts['onKeyDown']  ✅
  ↓
预览时查找 trigger === 'onKeyDown'  ✅
  ↓
找到积木 → 开始执行
```

```
按下 W 键
  ↓
传入 'KeyW'  ✅
  ↓
积木期望 'KeyW'  ✅
  ↓
按键匹配 → 执行移动
```

## 测试验证

### 测试用例 1：WASD 控制移动

**AI 提示词**：用WASD键控制角色移动

**期望生成**：
```json
[
  { "type": "event_keypress", "values": { "key": "KeyW" } },
  { "type": "motion_move", "values": { "direction": "up", "distance": 10 } },
  { "type": "event_keypress", "values": { "key": "KeyS" } },
  { "type": "motion_move", "values": { "direction": "down", "distance": 10 } },
  { "type": "event_keypress", "values": { "key": "KeyA" } },
  { "type": "motion_move", "values": { "direction": "left", "distance": 10 } },
  { "type": "event_keypress", "values": { "key": "KeyD" } },
  { "type": "motion_move", "values": { "direction": "right", "distance": 10 } }
]
```

**保存位置**：`component.scripts['onKeyDown']`

**预览时**：
1. 按下 W 键 → 触发 `onKeyDown` 事件
2. 引擎查找 `trigger === 'onKeyDown'` 的脚本 → 找到
3. 执行 `event_keypress(key: "KeyW")` → 匹配成功
4. 执行 `motion_move(direction: "up")` → 角色向上移动 ✅

### 测试用例 2：空格键跳跃

**AI 提示词**：按空格键跳跃

**期望生成**：
```json
[
  { "type": "event_keypress", "values": { "key": "Space" } },
  { "type": "motion_setvelocity", "values": { "vx": 0, "vy": -20 } }
]
```

**预览时**：
1. 按下空格 → 触发 `onKeyDown('Space')`
2. 匹配成功 → 执行跳跃 ✅

### 测试用例 3：点击按钮跳转场景

**AI 提示词**：点击按钮跳转到游戏场景

**期望生成**：
```json
[
  { "type": "event_click", "values": {} },
  { "type": "state_gotoscene", "values": { "sceneId": "游戏场景" } }
]
```

**保存位置**：`component.scripts['onClick']`

**预览时**：
1. 点击按钮 → 触发 `onClick` 事件
2. 查找并执行 → 跳转场景 ✅

## 影响范围

### ✅ 修复的功能
1. **WASD 控制移动** - 按键事件正常触发
2. **空格键/方向键** - 特殊按键支持
3. **点击事件** - 触发器命名统一
4. **碰撞事件** - 触发器命名统一
5. **场景初始化** - 新增支持 `event_sceneinit`

### ✅ 向后兼容
- 已有的手动创建的积木：不受影响（如果使用了错误的触发器键名，需要重新保存）
- 已有的 AI 生成积木：需要重新生成（旧的使用错误键名）

### ⚠️ 需要注意
如果之前保存了使用错误键名的积木：
1. 打开逻辑编辑器
2. 重新"生成"或手动修改
3. 保存后即可正常工作

## 调试方法

### 查看触发器键名

打开浏览器控制台（F12），使用 AI 生成积木后会看到：

```
[RightSidebar] AI生成积木分配到触发器: onKeyDown
[RightSidebar] 积木数量: 4
[RightSidebar] 积木详情: event_keypress -> motion_move -> event_keypress -> motion_move
```

确认 `触发器` 显示为 `onKeyDown`（而不是 `keydown`）。

### 查看按键事件

在 GameEngine.ts 中可以添加调试日志：

```typescript
handleKeyDown(key: string): void {
  console.log('[GameEngine] 按键按下:', key);  // 应该显示 'KeyW' 而不是 'w'
  // ...
}
```

## 后续优化建议

1. **统一事件命名规范**
   - 建立事件命名文档
   - 所有触发器统一使用驼峰命名

2. **按键值标准化**
   - 参考 Web 标准的 `KeyboardEvent.code` 属性
   - 所有按键使用标准格式（`KeyW`, `Space`, `ArrowUp` 等）

3. **添加单元测试**
   - 测试触发器映射逻辑
   - 测试按键值转换逻辑

---

**修复完成！现在预览模式可以正确响应 WASD 按键控制了。** 🎮

## 使用步骤

1. **刷新浏览器**（Ctrl + Shift + R）
2. **访问** http://localhost:3007/
3. **选择组件**
4. **使用 AI 助手**生成"用WASD键控制移动"
5. **打开预览模式**
6. **按下 WASD 键** → 角色应该会移动了！✅
