import type { Page, ComponentInstance } from '@/types/miniprogram';

export class WXMLGenerator {
  private indent = '  ';

  /**
   * 生成页面完整 WXML
   */
  generatePage(page: Page): string {
    let wxml = `<!-- ${page.name} -->\n`;
    wxml += `<!-- Generated by MiniProgram Studio -->\n\n`;
    wxml += this.generateComponents(page.components, 0);
    return wxml;
  }

  /**
   * 生成组件列表
   */
  private generateComponents(components: ComponentInstance[], depth: number): string {
    if (!components || components.length === 0) {
      return '';
    }

    return components.map((comp) => this.generateComponent(comp, depth)).join('\n');
  }

  /**
   * 生成单个组件
   */
  private generateComponent(component: ComponentInstance, depth: number): string {
    const indent = this.indent.repeat(depth);
    const { type, props, events } = component;

    // 开始标签
    let tag = `<${type}`;

    // 添加属性
    tag += this.generateAttributes(component);

    // 添加事件绑定
    if (events && events.length > 0) {
      tag += this.generateEvents(component);
    }

    // 添加内联样式（作为 style 属性）
    const inlineStyle = this.generateInlineStyle(component.styles);
    if (inlineStyle) {
      tag += ` style="${inlineStyle}"`;
    }

    // 添加 class（用于外部样式）
    if (component.id) {
      tag += ` class="comp-${component.id.slice(0, 8)}"`;
    }

    // 判断是否需要闭合标签
    const hasChildren = component.children && component.children.length > 0;
    const isSelfClosing = ['image', 'input', 'icon'].includes(type);

    if (!hasChildren && isSelfClosing) {
      return indent + tag + ' />\n';
    }

    tag += '>\n';

    // 添加内容
    if (props?.content) {
      tag += indent + this.indent + `${props.content}\n`;
    }

    // 递归生成子组件
    if (hasChildren) {
      tag += this.generateComponents(component.children, depth + 1);
    }

    // 结束标签
    tag += `${indent}</${type}>\n`;

    return tag;
  }

  /**
   * 生成组件属性
   */
  private generateAttributes(component: ComponentInstance): string {
    const { props } = component;
    const attrs: string[] = [];

    // 跳过特殊属性
    const skipProps = ['content'];

    for (const [key, value] of Object.entries(props)) {
      if (skipProps.includes(key)) continue;
      if (value === undefined || value === null || value === '') continue;

      if (key === 'className' || key === 'class') continue;

      if (typeof value === 'boolean') {
        if (value) attrs.push(` ${key}`);
      } else if (typeof value === 'string' && (value.startsWith('{{') || key.startsWith('bind') || key.startsWith('catch'))) {
        attrs.push(` ${key}="${value}"`);
      } else {
        attrs.push(` ${key}="${value}"`);
      }
    }

    return attrs.join('');
  }

  /**
   * 生成事件绑定
   */
  private generateEvents(component: ComponentInstance): string {
    if (!component.events || component.events.length === 0) {
      return '';
    }

    return component.events
      .map((event) => ` bind${event.trigger}="${event.trigger}Handler_${component.id.slice(0, 8)}"`)
      .join('');
  }

  /**
   * 生成内联样式
   */
  private generateInlineStyle(styles: Record<string, unknown>): string {
    if (!styles || Object.keys(styles).length === 0) {
      return '';
    }

    return Object.entries(styles)
      .filter(([_, value]) => value !== undefined && value !== null && value !== '')
      .map(([key, value]) => {
        const cssKey = this.camelToKebab(key);
        let cssValue = String(value);
        // 转换 px 为 rpx
        if (cssValue.endsWith('px')) {
          cssValue = cssValue.replace('px', 'rpx');
        }
        return `${cssKey}: ${cssValue}`;
      })
      .join('; ');
  }

  /**
   * 驼峰命名转短横线命名
   */
  private camelToKebab(str: string): string {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * 生成 app.json 中的页面路径列表
   */
  generatePageList(pages: Page[]): string[] {
    return pages.map((page) => page.path);
  }
}

export default new WXMLGenerator();
