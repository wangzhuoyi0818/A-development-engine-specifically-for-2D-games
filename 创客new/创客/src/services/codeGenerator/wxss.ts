import type { Page, ComponentInstance } from '@/types/miniprogram';

export class WXSSGenerator {
  private rpxRatio = 2; // 1px = 2rpx (假设设计稿 750rpx)

  /**
   * 生成页面完整 WXSS
   */
  generatePage(page: Page): string {
    let wxss = `/* ${page.name} */\n`;
    wxss += `/* Generated by MiniProgram Studio */\n\n`;

    // 生成页面容器样式
    wxss += this.generatePageStyles(page);

    // 生成组件样式
    wxss += this.generateComponentStyles(page.components);

    return wxss;
  }

  /**
   * 生成页面容器样式
   */
  private generatePageStyles(page: Page): string {
    let styles = 'page {\n';
    styles += '  width: 100%;\n';
    styles += '  height: 100%;\n';

    if (page.config?.backgroundColor) {
      styles += `  background-color: ${page.config.backgroundColor};\n`;
    }

    if (page.styles) {
      for (const [key, value] of Object.entries(page.styles)) {
        if (value) {
          styles += `  ${this.camelToKebab(key)}: ${this.convertUnit(value)};\n`;
        }
      }
    }

    styles += '}\n\n';
    return styles;
  }

  /**
   * 生成组件样式
   */
  private generateComponentStyles(components: ComponentInstance[]): string {
    let styles = '';

    for (const component of components) {
      styles += this.generateSingleComponentStyles(component);
      // 递归处理子组件
      if (component.children) {
        styles += this.generateComponentStyles(component.children);
      }
    }

    return styles;
  }

  /**
   * 生成单个组件样式
   */
  private generateSingleComponentStyles(component: ComponentInstance): string {
    let styles = '';

    const className = `.comp-${component.id.slice(0, 8)}`;
    const componentStyles = component.styles;

    if (componentStyles && Object.keys(componentStyles).length > 0) {
      styles += `${className} {\n`;
      styles += this.convertStylesToWXSS(componentStyles);
      styles += '}\n\n';
    }

    return styles;
  }

  /**
   * 转换样式对象为 WXSS 格式
   */
  private convertStylesToWXSS(styles: Record<string, unknown>): string {
    let result = '';

    const styleMap: Record<string, string> = {
      backgroundColor: 'background-color',
      backgroundImage: 'background-image',
      backgroundSize: 'background-size',
      color: 'color',
      fontSize: 'font-size',
      fontWeight: 'font-weight',
      textAlign: 'text-align',
      lineHeight: 'line-height',
      width: 'width',
      height: 'height',
      minWidth: 'min-width',
      minHeight: 'min-height',
      maxWidth: 'max-width',
      maxHeight: 'max-height',
      marginTop: 'margin-top',
      marginBottom: 'margin-bottom',
      marginLeft: 'margin-left',
      marginRight: 'margin-right',
      paddingTop: 'padding-top',
      paddingBottom: 'padding-bottom',
      paddingLeft: 'padding-left',
      paddingRight: 'padding-right',
      borderWidth: 'border-width',
      borderColor: 'border-color',
      borderRadius: 'border-radius',
      opacity: 'opacity',
      display: 'display',
      flexDirection: 'flex-direction',
      justifyContent: 'justify-content',
      alignItems: 'align-items',
      flexWrap: 'flex-wrap',
      gap: 'gap',
    };

    for (const [key, value] of Object.entries(styles)) {
      if (value !== undefined && value !== null && value !== '') {
        const wxssKey = styleMap[key] || key;
        const wxssValue = this.convertUnit(value);
        result += `  ${wxssKey}: ${wxssValue};\n`;
      }
    }

    return result;
  }

  /**
   * 转换单位
   */
  private convertUnit(value: unknown): string {
    if (typeof value === 'number') {
      return `${value * this.rpxRatio}rpx`;
    }

    if (typeof value === 'string') {
      // 转换 px 到 rpx
      if (value.endsWith('px')) {
        const numValue = parseFloat(value);
        return `${numValue * this.rpxRatio}rpx`;
      }
    }

    return String(value);
  }

  /**
   * 驼峰命名转短横线命名
   */
  private camelToKebab(str: string): string {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  }

  /**
   * 生成全局样式
   */
  generateGlobalStyles(globalStyles: Record<string, unknown>): string {
    let wxss = '/* 全局样式 */\n';
    wxss += '/* Generated by MiniProgram Studio */\n\n';

    wxss += 'page {\n';
    for (const [key, value] of Object.entries(globalStyles)) {
      wxss += `  ${this.camelToKebab(key)}: ${this.convertUnit(value)};\n`;
    }
    wxss += '}\n\n';

    return wxss;
  }
}

export default new WXSSGenerator();
