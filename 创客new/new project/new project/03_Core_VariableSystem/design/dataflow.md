# 变量系统数据流设计

## 1. 概述

本文档描述微信小程序可视化开发平台变量系统的数据流动和交互机制。

## 2. 核心数据流

### 2.1 变量创建流程

```
┌─────────────┐
│   用户操作   │ (在编辑器中创建变量)
└──────┬──────┘
       │
       ▼
┌─────────────────────────────────┐
│  VariablesContainer.insertNew() │
└──────┬──────────────────────────┘
       │
       ▼
┌──────────────────────┐
│  new Variable()      │ (创建 Variable 实例)
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  设置初始类型和值      │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  添加到容器变量列表    │
└──────────────────────┘
```

**示例代码:**
```typescript
const container = VariablesContainer.createGlobalContainer();

// 创建基本类型变量
const scoreVar = container.insertNew('score');
scoreVar.setValue(0);

// 创建结构体变量
const playerVar = container.insertNew('player');
playerVar.castTo(VariableType.Structure);
playerVar.getChild('health').setValue(100);
playerVar.getChild('mana').setValue(50);
```

### 2.2 变量访问流程

#### 2.2.1 直接访问

```
┌─────────────┐
│  get('name')│
└──────┬──────┘
       │
       ▼
┌──────────────────────┐
│  查找变量列表          │
└──────┬───────────────┘
       │
       ├─ 找到 ──────┐
       │             ▼
       │        ┌────────────┐
       │        │ 返回变量    │
       │        └────────────┘
       │
       └─ 未找到 ────┐
                     ▼
                ┌──────────────┐
                │  自动创建新变量│
                └──────┬───────┘
                       │
                       ▼
                ┌──────────────┐
                │  返回新变量   │
                └──────────────┘
```

#### 2.2.2 路径访问

```
┌──────────────────────┐
│ resolve('player.health')│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  parsePath()         │ (解析路径为段)
│  root: 'player'      │
│  segments: ['health']│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  container.get('player')│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  variable.getChild('health')│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  返回健康值变量       │
└──────────────────────┘
```

**示例代码:**
```typescript
const resolver = new VariableResolver(container);

// 解析路径
const healthVar = resolver.resolve('player.health');

// 获取值
const healthValue = resolver.getValue('player.health'); // 返回 100

// 设置值
resolver.setValue('player.health', 80);
```

### 2.3 变量更新流程(无响应式)

```
┌─────────────┐
│ setValue(50)│
└──────┬──────┘
       │
       ▼
┌──────────────────────┐
│  更新内部值           │
│  this.numberValue = 50│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  设置类型为 Number    │
│  this.type = Number   │
└──────────────────────┘
```

### 2.4 响应式更新流程

```
┌─────────────────────┐
│ reactive.set(path, value)│
└──────┬──────────────┘
       │
       ▼
┌──────────────────────┐
│  获取旧值             │
│  oldValue = get(path)│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  resolver.setValue() │ (设置新值)
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  notifyWatchers()    │ (通知监听器)
└──────┬───────────────┘
       │
       ├──────────────┬──────────────┐
       │              │              │
       ▼              ▼              ▼
┌────────────┐ ┌────────────┐ ┌────────────┐
│ Watcher 1  │ │ Watcher 2  │ │ Watcher 3  │
│ callback() │ │ callback() │ │ callback() │
└────────────┘ └────────────┘ └────────────┘
       │              │              │
       └──────────────┴──────────────┘
                      │
                      ▼
            ┌─────────────────┐
            │  notifyDeepWatchers()│
            │  (触发父路径深度监听)│
            └─────────────────┘
```

**示例代码:**
```typescript
const reactive = new ReactiveManager(container);

// 注册监听器
reactive.watch('player.health', (newValue, oldValue) => {
  console.log(`Health changed from ${oldValue} to ${newValue}`);
});

// 触发更新
reactive.set('player.health', 80);
// 输出: Health changed from 100 to 80
```

## 3. 计算属性数据流

### 3.1 计算属性定义和计算流程

```
┌─────────────────────────────────┐
│ defineComputed(name, getter, deps)│
└──────┬──────────────────────────┘
       │
       ▼
┌──────────────────────┐
│  创建 ComputedProperty│
│  - id               │
│  - getter           │
│  - dependencies     │
│  - dirty = true     │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  监听所有依赖变量      │
│  watch(dep, markDirty)│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  保存到 computed Map  │
└──────────────────────┘

───────────────────────────────────

┌─────────────────────┐
│ getComputed(name)   │
└──────┬──────────────┘
       │
       ▼
┌──────────────────────┐
│  检查 dirty 标志      │
└──────┬───────────────┘
       │
       ├─ dirty = false ──┐
       │                  ▼
       │            ┌──────────────┐
       │            │ 返回缓存值    │
       │            └──────────────┘
       │
       └─ dirty = true ───┐
                          ▼
                    ┌──────────────┐
                    │ 执行 getter() │
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │ 缓存结果      │
                    │ dirty = false│
                    └──────┬───────┘
                           │
                           ▼
                    ┌──────────────┐
                    │ 返回计算结果  │
                    └──────────────┘
```

**示例代码:**
```typescript
// 定义计算属性
reactive.defineComputed('fullHealth', () => {
  const current = reactive.get('player.health') as number;
  const max = reactive.get('player.maxHealth') as number;
  return `${current}/${max}`;
}, ['player.health', 'player.maxHealth']);

// 获取计算结果
console.log(reactive.getComputed('fullHealth')); // "100/150"

// 依赖变化,计算属性自动标记为 dirty
reactive.set('player.health', 80);

// 再次获取时重新计算
console.log(reactive.getComputed('fullHealth')); // "80/150"
```

### 3.2 计算属性依赖跟踪

```
┌─────────────────────┐
│  Computed Property  │
│  "fullName"         │
└──────┬──────────────┘
       │
       │ depends on
       │
       ├──────────────┬──────────────┐
       │              │              │
       ▼              ▼              ▼
┌────────────┐ ┌────────────┐ ┌────────────┐
│ firstName  │ │ lastName   │ │ middleName │
└────────────┘ └────────────┘ └────────────┘
       │              │              │
       │   changed    │              │
       └──────────────┴──────────────┘
                      │
                      ▼
            ┌─────────────────┐
            │ markDirty()     │
            │ dirty = true    │
            └─────────────────┘
```

## 4. 数据绑定流程

### 4.1 单向绑定

```
┌──────────────────────┐
│  bind(source, target, false)│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  watch(source, ...)  │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  Source 变化         │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  Watcher 回调触发    │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  setValue(target, newValue)│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  Target 更新         │
└──────────────────────┘
```

### 4.2 双向绑定

```
┌──────────────────────┐
│  bind(A, B, true)    │
└──────┬───────────────┘
       │
       ├─────────────────┬─────────────────┐
       │                 │                 │
       ▼                 ▼                 │
┌────────────┐    ┌────────────┐          │
│ watch(A)   │    │ watch(B)   │          │
│ → set(B)   │    │ → set(A)   │          │
└────────────┘    └────────────┘          │
       │                 │                 │
       └─────────────────┴─────────────────┘
                         │
                         ▼
                ┌────────────────┐
                │  A ⇄ B 双向同步 │
                └────────────────┘
```

**示例代码:**
```typescript
// 单向绑定
const watchers = reactive.bind('score', 'displayScore', false);
reactive.set('score', 100);
// displayScore 自动更新为 100

// 双向绑定
const watchers = reactive.bind('input', 'output', true);
reactive.set('input', 'hello');
// output 自动更新为 'hello'
reactive.set('output', 'world');
// input 自动更新为 'world'
```

## 5. 序列化和反序列化流程

### 5.1 序列化流程

```
┌──────────────────────┐
│  variable.toJSON()   │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  检查变量类型          │
└──────┬───────────────┘
       │
       ├─ Number/String/Boolean
       │     │
       │     ▼
       │  ┌─────────────────┐
       │  │ { type, value } │
       │  └─────────────────┘
       │
       ├─ Structure
       │     │
       │     ▼
       │  ┌─────────────────────┐
       │  │ { type, children:{} }│
       │  │  递归序列化子变量     │
       │  └─────────────────────┘
       │
       └─ Array
             │
             ▼
          ┌─────────────────────┐
          │ { type, childrenArray:[]}│
          │  递归序列化数组元素   │
          └─────────────────────┘
```

### 5.2 反序列化流程

```
┌──────────────────────┐
│  Variable.fromJSON() │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  new Variable()      │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  设置 type           │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  根据 type 设置值     │
└──────┬───────────────┘
       │
       ├─ Number/String/Boolean
       │     │
       │     ▼
       │  ┌─────────────────┐
       │  │ 设置 value      │
       │  └─────────────────┘
       │
       ├─ Structure
       │     │
       │     ▼
       │  ┌─────────────────────┐
       │  │  遍历 children{}    │
       │  │  递归反序列化        │
       │  └─────────────────────┘
       │
       └─ Array
             │
             ▼
          ┌─────────────────────┐
          │  遍历 childrenArray[]│
          │  递归反序列化        │
          └─────────────────────┘
```

**示例代码:**
```typescript
// 序列化
const json = container.toJSON();
console.log(JSON.stringify(json, null, 2));

// 保存到文件或网络传输
saveToFile('variables.json', json);

// 反序列化
const loadedJson = loadFromFile('variables.json');
const restoredContainer = VariablesContainer.fromJSON(loadedJson);
```

## 6. 跨模块数据流

### 6.1 编辑器 → 变量系统

```
┌──────────────┐
│  属性编辑器   │
│  (UI 输入)   │
└──────┬───────┘
       │
       ▼
┌──────────────────────┐
│  reactive.set()      │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  Variable 更新       │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  通知监听器           │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  UI 更新 (其他面板)   │
└──────────────────────┘
```

### 6.2 变量系统 → 代码生成器

```
┌──────────────────────┐
│  VariablesContainer  │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  container.toJSON()  │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  CodeGenerator       │
│  生成 Page.data      │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  输出 .js 文件        │
│  data: {             │
│    score: 0,         │
│    player: {...}     │
│  }                   │
└──────────────────────┘
```

### 6.3 变量系统 → 事件系统

```
┌──────────────────────┐
│  Event Handler       │
│  (点击事件)           │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  Action: SetVariable │
│  path: "score"       │
│  value: score + 10   │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  resolver.setValue() │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  触发响应式更新       │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  UI 自动刷新          │
└──────────────────────┘
```

## 7. 批量更新优化流程

```
┌──────────────────────┐
│  batchSet({          │
│    a: 1,             │
│    b: 2,             │
│    c: 3              │
│  })                  │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  收集所有路径到队列   │
│  queue = ['a','b','c']│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  立即设置所有值       │
│  resolver.setValues()│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  启动延迟定时器       │
│  setTimeout(flush, 0)│
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  下一个事件循环       │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  flushBatchUpdates() │
│  批量触发监听器       │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│  清空队列             │
└──────────────────────┘
```

**优势:**
- 避免多次修改同一变量时重复触发监听器
- 合并多个更新操作,减少 UI 重绘次数
- 提高性能,特别是在大量更新时

## 8. 典型使用场景

### 8.1 场景1: 用户输入更新变量

```
用户在输入框输入
    ↓
组件触发 input 事件
    ↓
事件处理器调用 reactive.set('name', value)
    ↓
变量更新
    ↓
触发 watcher 回调
    ↓
其他 UI 组件自动更新
```

### 8.2 场景2: 计算属性自动更新

```
定义计算属性: totalScore = score1 + score2
    ↓
score1 变化
    ↓
标记 totalScore 为 dirty
    ↓
UI 请求显示 totalScore
    ↓
重新计算并缓存
    ↓
返回最新值
```

### 8.3 场景3: 页面加载时恢复变量状态

```
加载项目文件 (JSON)
    ↓
解析 JSON
    ↓
VariablesContainer.fromJSON()
    ↓
递归创建 Variable 实例
    ↓
恢复所有变量值
    ↓
通知编辑器刷新 UI
```

## 9. 总结

变量系统的数据流设计遵循以下原则:

1. **单向数据流**: 数据总是从源头流向目标
2. **响应式更新**: 变量变化自动触发依赖更新
3. **按需计算**: 计算属性采用惰性求值和缓存
4. **批量优化**: 多次更新合并处理,减少开销
5. **可序列化**: 完整的持久化支持
6. **清晰职责**: 每个模块职责明确,易于维护

通过合理的数据流设计,变量系统能够高效地支持整个平台的数据管理需求。
