# API包装器模块 - 数据流设计

## 1. 数据流概述

API包装器模块的数据流包含以下几个关键阶段:
1. **请求准备阶段**: 参数验证、拦截器处理
2. **请求执行阶段**: 并发控制、实际API调用
3. **响应处理阶段**: 响应拦截、数据转换
4. **错误处理阶段**: 错误捕获、重试决策
5. **结果返回阶段**: Promise resolve/reject

## 2. 完整数据流图

```
┌─────────────────────────────────────────────────────────────┐
│                      业务代码调用                            │
│           network.request({ url, method, data })            │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 1: 参数验证                            │
│  - 检查必填参数                                              │
│  - 验证参数类型                                              │
│  - 设置默认值                                                │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 2: 请求拦截器                          │
│  ┌──────────────┐  ┌──────────────┐  ┌─────────────────┐   │
│  │ Token拦截器  │→│ 签名拦截器    │→│ 自定义拦截器     │   │
│  └──────────────┘  └──────────────┘  └─────────────────┘   │
│  options → options' → options'' → options'''               │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 3: 并发控制                            │
│  当前并发数 < 限制?                                          │
│      是 → 继续                                               │
│      否 → 等待队列                                           │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 4: 缓存检查                            │
│  是否启用缓存 && 缓存命中?                                    │
│      是 → 直接返回缓存数据                                    │
│      否 → 继续请求                                           │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 5: Mock检查                            │
│  开发环境 && Mock启用?                                       │
│      是 → 返回Mock数据                                       │
│      否 → 调用真实API                                        │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 6: 调用微信API                         │
│  wx[apiName]({                                              │
│    ...options,                                              │
│    success: (res) => {...},                                 │
│    fail: (err) => {...}                                     │
│  })                                                         │
└─────────────────────────────────────────────────────────────┘
                   │                    │
                成功 ▼                 失败 ▼
┌────────────────────────────┐  ┌──────────────────────────┐
│   Step 7a: 响应拦截器       │  │   Step 7b: 错误处理      │
│ - 数据格式转换              │  │ - 错误分类               │
│ - 业务逻辑处理              │  │ - 错误映射               │
│ - 数据验证                  │  │ - 错误上报               │
└────────────────────────────┘  └──────────────────────────┘
                   │                    │
                   │                    ▼
                   │         ┌──────────────────────────┐
                   │         │   Step 8: 重试判断       │
                   │         │ 应该重试?                │
                   │         │  是 → 回到Step 6         │
                   │         │  否 → 抛出错误           │
                   │         └──────────────────────────┘
                   │                    │
                   ▼                    ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 9: 缓存更新                            │
│  成功响应 → 更新缓存                                         │
│  失败响应 → 不更新缓存                                       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                  Step 10: 返回结果                           │
│  Promise.resolve(data) 或 Promise.reject(error)             │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                      业务代码接收                            │
│              const data = await network.request(...)        │
└─────────────────────────────────────────────────────────────┘
```

## 3. 关键数据结构流转

### 3.1 请求数据流转

```typescript
// 原始请求参数
type InputOptions = {
  url: string;
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
  data?: any;
  header?: Record<string, string>;
}

// 经过拦截器处理后的参数
type InterceptedOptions = InputOptions & {
  header: Record<string, string>;  // 添加了token、签名等
  timestamp?: number;  // 添加时间戳
  requestId?: string;  // 添加请求ID
}

// 微信API实际接收的参数
type WxAPIOptions = InterceptedOptions & {
  success: (res: any) => void;
  fail: (err: any) => void;
  complete?: () => void;
}
```

### 3.2 响应数据流转

```typescript
// 微信API原始响应
type WxAPIResponse = {
  statusCode: number;
  data: any;
  header: Record<string, string>;
  errMsg?: string;
}

// 经过响应拦截器处理后
type InterceptedResponse<T> = {
  data: T;
  metadata: {
    statusCode: number;
    headers: Record<string, string>;
    timestamp: number;
    requestId: string;
  }
}

// 最终返回给业务代码的数据
type FinalResponse<T> = T;  // 通常只返回data部分
```

### 3.3 错误数据流转

```typescript
// 微信API原始错误
type WxAPIError = {
  errMsg: string;
  errCode?: number;
}

// 标准化后的错误
type StandardError = {
  type: ErrorType;
  code: string;
  message: string;
  原始错误: any;
  recoverable: boolean;
}

// 业务代码接收的错误
type BusinessError = StandardError & {
  timestamp: number;
  requestId: string;
}
```

## 4. 典型场景数据流

### 4.1 成功请求场景

```
业务代码调用
  → 参数: { url: '/api/user', method: 'GET' }
  → 请求拦截器添加token
  → 参数: { url: '/api/user', method: 'GET', header: { Authorization: 'Bearer xxx' } }
  → 并发检查 (通过)
  → 缓存检查 (未命中)
  → 调用 wx.request
  → 微信响应: { statusCode: 200, data: { code: 0, data: { id: 1, name: 'Alice' } } }
  → 响应拦截器提取data字段
  → 缓存更新
  → 返回: { id: 1, name: 'Alice' }
业务代码接收
```

### 4.2 失败重试场景

```
业务代码调用
  → 参数: { url: '/api/data', method: 'GET' }
  → 请求拦截器处理
  → 调用 wx.request (第1次)
  → 失败: { errMsg: 'request:fail timeout' }
  → 错误处理器: ErrorType.TIMEOUT
  → 重试判断: shouldRetry = true
  → 延迟 1000ms
  → 调用 wx.request (第2次)
  → 失败: { errMsg: 'request:fail timeout' }
  → 重试判断: shouldRetry = true
  → 延迟 2000ms
  → 调用 wx.request (第3次)
  → 成功: { statusCode: 200, data: {...} }
  → 响应拦截器处理
  → 返回数据
业务代码接收
```

### 4.3 并发控制场景

```
业务代码同时发起10个请求
  Request 1-10 → 并发控制器

并发控制器状态:
  - 限制: 10
  - 活跃: 0

Request 1-10 → 立即执行 (活跃: 10)

业务代码再发起Request 11
  Request 11 → 并发控制器 → 等待队列

Request 1 完成 → 活跃: 9 → Request 11 从队列出列 → 执行
```

### 4.4 缓存命中场景

```
业务代码调用 (第1次)
  → 参数: { url: '/api/config', method: 'GET' }
  → 缓存检查 (未命中)
  → 调用 wx.request
  → 响应: { data: { theme: 'dark' } }
  → 缓存更新: key='/api/config', data={theme:'dark'}, ttl=5min
  → 返回数据

业务代码调用 (第2次, 3分钟后)
  → 参数: { url: '/api/config', method: 'GET' }
  → 缓存检查 (命中且未过期)
  → 直接返回缓存数据: { theme: 'dark' }
  → 跳过网络请求
```

## 5. 拦截器链数据流

### 5.1 请求拦截器链

```
原始options
  │
  ▼
┌─────────────────────┐
│ Interceptor 1       │  添加公共header
│ options → options₁  │
└─────────────────────┘
  │
  ▼
┌─────────────────────┐
│ Interceptor 2       │  添加token
│ options₁ → options₂ │
└─────────────────────┘
  │
  ▼
┌─────────────────────┐
│ Interceptor 3       │  添加签名
│ options₂ → options₃ │
└─────────────────────┘
  │
  ▼
最终options₃ → 发送请求
```

### 5.2 响应拦截器链

```
微信API响应
  │
  ▼
┌─────────────────────┐
│ Interceptor 1       │  提取data字段
│ response → data     │
└─────────────────────┘
  │
  ▼
┌─────────────────────┐
│ Interceptor 2       │  验证业务码
│ data → validData    │
└─────────────────────┘
  │
  ▼
┌─────────────────────┐
│ Interceptor 3       │  数据转换
│ validData → model   │
└─────────────────────┘
  │
  ▼
最终model → 返回业务代码
```

## 6. 错误处理数据流

### 6.1 错误捕获和转换

```
微信API错误
  │
  ▼
┌─────────────────────────────┐
│ 原始错误                     │
│ { errMsg: 'request:fail...' }│
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 错误分类器                   │
│ errMsg → ErrorType           │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 错误映射器                   │
│ ErrorType → 业务错误码       │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 标准化错误对象               │
│ APIError {                   │
│   type, code, message       │
│ }                            │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 错误处理器链                 │
│ - 日志记录                   │
│ - 错误上报                   │
│ - 用户提示                   │
└─────────────────────────────┘
  │
  ▼
抛出或重试
```

## 7. Mock数据流

### 7.1 开发环境Mock

```
业务代码调用
  │
  ▼
┌─────────────────────────────┐
│ Mock检查                     │
│ process.env.NODE_ENV === 'dev'?│
└─────────────────────────────┘
  │
  是 ▼
┌─────────────────────────────┐
│ Mock管理器                   │
│ - 根据URL匹配Mock规则        │
│ - 模拟延迟                   │
│ - 模拟错误率                 │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 返回Mock数据                 │
│ mockData[url]                │
└─────────────────────────────┘
  │
  ▼
业务代码接收Mock数据

  否 ▼
调用真实API
```

## 8. 缓存数据流

### 8.1 缓存读写流程

```
请求发起
  │
  ▼
┌─────────────────────────────┐
│ 生成缓存Key                  │
│ key = hash(url + params)     │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 检查缓存                     │
│ cache.get(key)               │
└─────────────────────────────┘
  │
  命中 ▼                       未命中 ▼
┌─────────────────────┐    ┌─────────────────────┐
│ 检查是否过期         │    │ 发起真实请求        │
└─────────────────────┘    └─────────────────────┘
  │                          │
  未过期 ▼   过期 ▼          ▼
  返回缓存    发起请求    ┌──────────────────┐
                          │ 缓存响应数据     │
                          │ cache.set(key,   │
                          │   data, ttl)     │
                          └──────────────────┘
                              │
                              ▼
                          返回数据
```

## 9. 重试机制数据流

### 9.1 指数退避重试

```
请求失败
  │
  ▼
┌─────────────────────────────┐
│ 重试判断                     │
│ shouldRetry(error)?          │
└─────────────────────────────┘
  │
  是 ▼                         否 → 抛出错误
┌─────────────────────────────┐
│ 检查重试次数                 │
│ attemptCount < maxRetries?   │
└─────────────────────────────┘
  │
  是 ▼                         否 → 抛出错误
┌─────────────────────────────┐
│ 计算延迟时间                 │
│ delay = initialDelay *       │
│   (backoffMultiplier ^ n)    │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 等待延迟                     │
│ await sleep(delay)           │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 发起重试请求                 │
│ attemptCount++               │
└─────────────────────────────┘
  │
  ▼
成功 → 返回数据
失败 → 回到"重试判断"
```

## 10. 性能监控数据流

### 10.1 请求性能追踪

```
请求开始
  │
  ▼
┌─────────────────────────────┐
│ 记录开始时间                 │
│ startTime = Date.now()       │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 生成请求ID                   │
│ requestId = uuid()           │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 执行请求                     │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 记录结束时间                 │
│ endTime = Date.now()         │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 计算性能指标                 │
│ - duration: endTime-startTime│
│ - retryCount                 │
│ - cacheHit                   │
└─────────────────────────────┘
  │
  ▼
┌─────────────────────────────┐
│ 上报性能数据                 │
│ analytics.report({           │
│   requestId, duration, ...   │
│ })                           │
└─────────────────────────────┘
```

## 11. 总结

API包装器的数据流设计包含以下关键特性:

1. **多层拦截**: 请求和响应都经过多层拦截器处理
2. **智能缓存**: 支持缓存检查和更新
3. **自动重试**: 失败后自动重试,使用指数退避策略
4. **并发控制**: 限制同时请求数量,防止资源耗尽
5. **Mock支持**: 开发环境支持Mock数据
6. **性能监控**: 记录和上报请求性能指标
7. **错误处理**: 统一的错误捕获、转换和处理流程

这种设计确保了数据流的清晰性、可维护性和可扩展性。
