/**
 * WXSS生成器 - 格式化器
 *
 * 生成格式规范的WXSS代码，支持压缩和美化
 */

import type {
  CSSRule,
  FormatOptions,
  BeautifyOptions,
  SourceMap,
  WXSSGenerateOptions,
} from './types';

// ============================================================================
// CSS格式化器类
// ============================================================================

/**
 * CSS格式化器
 *
 * 职责:
 * - 生成格式规范的WXSS代码
 * - 支持压缩和美化两种模式
 * - 生成源代码映射
 */
export class CSSFormatter {
  /**
   * 格式化CSS规则
   * @param rules CSS规则
   * @param options 生成选项
   * @returns 格式化后的WXSS字符串
   */
  format(rules: CSSRule[], options?: WXSSGenerateOptions): string {
    if (!rules || rules.length === 0) {
      return '';
    }

    // 根据选项选择格式化方式
    if (options?.minify) {
      return this.minify(this.beautify(rules, options));
    }

    if (options?.beautify !== false) {
      return this.beautify(rules, options);
    }

    // 默认压缩
    return this.minify(this.beautify(rules, options));
  }

  /**
   * 美化CSS代码
   * @param rules CSS规则
   * @param options 美化选项
   * @returns 美化后的字符串
   */
  beautify(rules: CSSRule[] | string, options?: WXSSGenerateOptions | BeautifyOptions): string {
    // 如果输入是字符串，直接返回
    if (typeof rules === 'string') {
      return this.beautifyString(rules, options as BeautifyOptions);
    }

    // 合并媒体查询规则
    const grouped = this.groupByMedia(rules);
    const indent = ' '.repeat((options as BeautifyOptions)?.indent || 2);
    const lines: string[] = [];

    // 添加注释头
    if ((options as WXSSGenerateOptions)?.comments !== false) {
      lines.push('/* 自动生成 - 请勿手动修改 */');
      lines.push('/* Generated by WXSS Generator */');
      lines.push('');
    }

    // 输出普通规则
    if (grouped.normal && grouped.normal.length > 0) {
      for (const rule of grouped.normal) {
        lines.push(this.formatRule(rule, 0, indent));
      }
      lines.push('');
    }

    // 输出媒体查询
    if (grouped.media && Object.keys(grouped.media).length > 0) {
      for (const [media, mediaRules] of Object.entries(grouped.media)) {
        lines.push(`@media ${media} {`);
        for (const rule of mediaRules) {
          lines.push(this.formatRule(rule, 1, indent));
        }
        lines.push('}');
        lines.push('');
      }
    }

    return lines.join('\n').trim();
  }

  /**
   * 压缩CSS代码
   * @param css CSS字符串
   * @returns 压缩后的字符串
   */
  minify(css: string): string {
    return css
      // 移除注释
      .replace(/\/\*[\s\S]*?\*\//g, '')
      // 移除多余空格
      .replace(/\s+/g, ' ')
      // 移除选择器周围的空格
      .replace(/\s*([{}:;,])\s*/g, '$1')
      // 移除分号前的空格
      .replace(/;\s*}/g, '}')
      // 移除行尾空格
      .trim();
  }

  /**
   * 优化CSS代码
   * @param css CSS字符串
   * @returns 优化后的字符串
   */
  optimize(css: string): string {
    // 移除重复的规则
    const rules = css.match(/[^{}]+\{[^}]*\}/g) || [];
    const uniqueRules = new Set(rules);

    // 合并相同的选择器
    const grouped: Record<string, string> = {};
    for (const rule of uniqueRules) {
      const match = rule.match(/^([^{]+)\{([^}]*)\}$/);
      if (match) {
        const selector = match[1].trim();
        const properties = match[2].trim();

        if (!grouped[selector]) {
          grouped[selector] = properties;
        } else {
          // 合并属性
          grouped[selector] = `${grouped[selector]};${properties}`;
        }
      }
    }

    // 重新生成CSS
    return Object.entries(grouped)
      .map(([selector, properties]) => `${selector}{${properties}}`)
      .join('');
  }

  /**
   * 生成源映射
   * @param css CSS字符串
   * @param sourceRules 源规则
   * @returns 源映射对象
   */
  generateSourceMap(css: string, sourceRules: CSSRule[]): SourceMap {
    const mappings: number[][] = [];
    let generatedLine = 0;
    let generatedColumn = 0;

    for (let i = 0; i < sourceRules.length; i++) {
      const rule = sourceRules[i];

      // 记录选择器位置
      const selectorStart = [
        i,
        0,
        generatedLine,
        generatedColumn,
      ];

      mappings.push(selectorStart as any);

      // 更新生成的位置
      generatedLine++;
      generatedColumn = 0;
    }

    // 编码mappings
    const encoded = this.encodeSourceMap(mappings);

    return {
      version: 3,
      sources: sourceRules
        .filter((r) => r.sourceId)
        .map((r) => `component-${r.sourceId}.style`),
      mappings: encoded,
      sourcesContent: sourceRules.map((r) => JSON.stringify(r.properties)),
    };
  }

  /**
   * 格式化单个规则
   * @param rule CSS规则
   * @param depth 嵌套深度
   * @param indentStr 缩进字符串
   * @returns 格式化后的字符串
   */
  private formatRule(rule: CSSRule, depth: number = 0, indentStr: string = '  '): string {
    const indent = indentStr.repeat(depth);
    const propertyIndent = indentStr.repeat(depth + 1);

    let result = `${indent}${rule.selector} {\n`;

    // 格式化属性
    for (const [key, value] of Object.entries(rule.properties)) {
      result += `${propertyIndent}${key}: ${value};\n`;
    }

    result += `${indent}}\n`;

    return result;
  }

  /**
   * 美化字符串
   * @param css CSS字符串
   * @param options 美化选项
   * @returns 美化后的字符串
   */
  private beautifyString(css: string, options?: BeautifyOptions): string {
    const indent = ' '.repeat(options?.indent || 2);
    let result = '';
    let indentLevel = 0;

    for (let i = 0; i < css.length; i++) {
      const char = css[i];
      const nextChar = css[i + 1];

      if (char === '{') {
        result += ' {\n';
        indentLevel++;
        result += indent.repeat(indentLevel);
      } else if (char === '}') {
        result += '\n';
        indentLevel--;
        result += indent.repeat(indentLevel) + '}\n';
      } else if (char === ';' && nextChar !== '\n') {
        result += ';\n';
        result += indent.repeat(indentLevel);
      } else if (char !== '\n' && char !== ' ' && char !== '\t') {
        result += char;
      } else if (result[result.length - 1] !== ' ' && result[result.length - 1] !== '\n') {
        result += char;
      }
    }

    return result.trim();
  }

  /**
   * 按媒体查询分组
   * @param rules CSS规则
   * @returns 分组结果
   */
  private groupByMedia(
    rules: CSSRule[]
  ): {
    normal: CSSRule[];
    media: Record<string, CSSRule[]>;
  } {
    const normal: CSSRule[] = [];
    const media: Record<string, CSSRule[]> = {};

    for (const rule of rules) {
      if (rule.media) {
        if (!media[rule.media]) {
          media[rule.media] = [];
        }
        media[rule.media].push(rule);
      } else {
        normal.push(rule);
      }
    }

    return { normal, media };
  }

  /**
   * 编码源映射
   * @param mappings 映射数据
   * @returns 编码后的字符串
   */
  private encodeSourceMap(mappings: number[][]): string {
    const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    const encode = (num: number): string => {
      if (num < 0) {
        num = (-num << 1) | 1;
      } else {
        num = num << 1;
      }

      let result = '';
      do {
        let clamped = num & 31;
        num >>>= 5;

        if (num > 0) {
          clamped |= 32;
        }

        result += BASE64_CHARS[clamped];
      } while (num > 0);

      return result;
    };

    let lastSourceFile = 0;
    let lastSourceLine = 0;
    let lastSourceColumn = 0;

    let result = '';

    for (const mapping of mappings) {
      if (mapping.length > 0) {
        result += encode(mapping[2] - lastSourceLine);
        lastSourceLine = mapping[2];

        result += encode(mapping[3] - lastSourceColumn);
        lastSourceColumn = mapping[3];

        if (mapping.length > 1) {
          result += encode(mapping[0] - lastSourceFile);
          lastSourceFile = mapping[0];

          result += encode(mapping[1]);
        }
      }

      result += ',';
    }

    return result.slice(0, -1);
  }

  /**
   * 排序CSS属性
   * @param properties CSS属性
   * @returns 排序后的属性
   */
  private sortProperties(properties: Record<string, string>): Record<string, string> {
    const sorted: Record<string, string> = {};
    const keys = Object.keys(properties).sort();

    for (const key of keys) {
      sorted[key] = properties[key];
    }

    return sorted;
  }
}

// ============================================================================
// 导出
// ============================================================================

export default CSSFormatter;
