# 积木系统调试经验总结

**日期**: 2026-01-27
**任务**: 修复 AI 生成的敌人追踪玩家积木无法工作的问题

---

## 问题现象

用户使用 AI 助手生成"让僵尸追踪玩家"的积木后，在预览模式下僵尸完全不会移动，无法追踪玩家。

---

## 调试过程与关键发现

### 第1阶段：确认积木生成和保存正常

**操作**: 查看控制台日志

**发现**:
- ✅ AI 成功生成了 `motion_followtarget` 积木
- ✅ 积木被保存到 `component.scripts['onGameStart']`
- ✅ 积木数据结构完整

**结论**: 问题不在积木生成阶段

---

### 第2阶段：发现 GamePreviewTest 缺少自动脚本执行

**关键日志**:
```
[GamePreviewTest] 🕹️ 摇杆状态: ...  // ✅ 大量摇杆日志
```
但**没有任何 GameEngine 日志**（如 `FRAME_UPDATE`、`executeScriptsWithTrigger` 等）

**根本原因**:
- 用户使用的是 `GamePreviewTest.tsx`（简化版预览）
- GamePreviewTest **不使用 GameEngine**，只手动处理键盘/摇杆/点击事件
- GamePreviewTest **从未执行 `onGameStart` 或 `onUpdate` 脚本**

**解决方案**:
1. 添加 `onGameStart` 脚本自动执行（场景加载时）
2. 添加 `onUpdate` 脚本每帧执行
3. 改造游戏循环为持续运行（而非只在有输入时运行）

**修改代码**: `GamePreviewTest.tsx` 第65-185行

---

### 第3阶段：实现 motion_followtarget 积木逻辑

**问题**: GamePreviewTest 的 `executeBlocks` 函数没有处理 `motion_followtarget` 积木

**解决方案**: 添加追踪逻辑实现
- 智能目标查找（ID → 名称 → 模糊匹配 → 玩家角色 → 关键词）
- 计算追踪方向向量
- 按速度移动组件
- 边界限制和防抖动

**修改代码**: `GamePreviewTest.tsx` 第267-395行

---

### 第4阶段：修复状态同步问题（核心bug！）

**关键日志**:
```
- 追踪者: 僵尸 @ (221.15, 290.95)  // 第1次
✅ 僵尸 移动完成

- 追踪者: 僵尸 @ (221.15, 290.95)  // 第2次 - 位置完全相同！
✅ 僵尸 移动完成

- 追踪者: 僵尸 @ (221.15, 290.95)  // 第3次 - 还是相同！
✅ 僵尸 移动完成
```

**根本原因**:
- `executeBlocks` 函数接收的 `component` 参数是**初始加载时的快照**
- `updateComponent` 更新了 store，但传入的 `component` 对象仍是旧的引用
- React 的 `currentPage` 变量也是函数开始时的快照，不会自动更新

**错误代码示例**:
```typescript
const executeBlocks = (blocks, component) => {
  // component 是快照，永远不会更新
  for (const block of blocks) {
    if (block.type === 'motion_followtarget') {
      // ❌ 使用快照位置
      const dx = target.position.x - component.position.x;

      updateComponent(component.id, { position: newPos });
      // ⚠️ 更新了 store，但 component 变量没变
    }
  }
}
```

**解决方案**: 在每次执行追踪逻辑时，动态从 store 实时获取最新状态

**正确代码**:
```typescript
const executeBlocks = (blocks, component) => {
  for (const block of blocks) {
    if (block.type === 'motion_followtarget') {
      // ✅ 实时从 store 获取最新页面
      const freshPage = getCurrentPage();
      const latestComponent = freshPage.components.find(c => c.id === component.id);

      // ✅ 使用最新位置计算
      const dx = target.position.x - latestComponent.position.x;

      updateComponent(latestComponent.id, { position: newPos });
      // ✅ 下次循环会再次获取最新状态
    }
  }
}
```

**修改代码**: `GamePreviewTest.tsx` 第193-280行（motion_move）、第282-395行（motion_followtarget）

**效果验证**:
```
- 追踪者: 僵尸 @ (221.15, 290.95)  // 第1次
- 追踪者: 僵尸 @ (219.82, 255.25)  // ✅ 位置更新了！
- 追踪者: 僵尸 @ (203.50, 266.79)  // ✅ 继续更新！
- 追踪者: 僵尸 @ (187.16, 278.34)  // ✅ 还在更新！
```

---

### 第5阶段：修复触发器分配逻辑（最终问题！）

**问题**: 即使积木能执行，也只在 `onGameStart` 中执行 1 次，而追踪需要**持续每帧执行**

**AI 生成的积木结构**:
```json
[
  { "type": "event_sceneinit" },      // 第1个积木
  { "type": "logic_forever" },        // 第2个积木
  { "type": "motion_followtarget" }   // 第3个积木
]
```

**旧的检测逻辑问题**:
```typescript
for (const block of blocks) {
  if (block.type === 'event_sceneinit') {
    triggerKey = 'onGameStart';
    break;  // ❌ 在第1个积木就停止了！
  }
  else if (block.type === 'motion_followtarget') {
    triggerKey = 'onUpdate';  // ⚠️ 永远不会执行到这里
    break;
  }
}
```

**结果**:
- 积木被分配到 `onGameStart`（场景初始化）
- 只在场景加载时执行 1 次
- 3次移动太快，视觉上感觉没动

**解决方案**: 调整检测优先级，优先检测追踪类型的积木

**新的检测逻辑**:
```typescript
// 【第1轮】优先检测持续行为类型
for (const block of blocks) {
  if (block.type === 'motion_followtarget' ||  // 🔥 追踪
      block.type === 'logic_forever' ||         // 🔥 永久循环
      block.type === 'event_timer' ||           // 定时器
      block.type === 'game_event_update') {     // 每帧更新
    triggerKey = 'onUpdate';  // ✅ 持续每帧执行
    break;
  }
}

// 【第2轮】如果没找到持续行为，再检查其他类型
if (triggerKey === 'tap') {
  for (const block of blocks) {
    if (block.type === 'event_keypress') {
      triggerKey = 'onKeyDown';
      break;
    }
    else if (block.type === 'event_sceneinit') {
      triggerKey = 'onGameStart';  // 最低优先级
      break;
    }
    // ... 其他类型
  }
}
```

**优先级排序**:
1. **最高**: 追踪/每帧执行 (`motion_followtarget`, `logic_forever`) → `onUpdate`
2. 按键控制 → `onKeyDown`
3. 点击 → `onClick`
4. 场景切换 → `onClick`
5. 碰撞 → `onCollision`
6. **最低**: 场景初始化 (`event_sceneinit`) → `onGameStart`

**修改代码**: `RightSidebar.tsx` 第250-310行

**效果验证**:
```
[RightSidebar] AI生成积木分配到触发器: onUpdate  // ✅ 正确！
```

---

## 核心经验总结

### 1. **理解预览模式的架构差异**

| 特性 | GamePreview (完整版) | GamePreviewTest (简化版) |
|------|---------------------|------------------------|
| 使用 GameEngine | ✅ 是 | ❌ 否 |
| 自动执行 onGameStart | ✅ 是 | ❌ 需要手动添加 |
| 自动执行 onUpdate | ✅ 是 | ❌ 需要手动添加 |
| 事件系统 | 完整的 EventSystem | 手动处理特定事件 |
| 状态管理 | GameStateManager | 直接操作 store |
| 适用场景 | 复杂游戏逻辑 | 快速测试、简单交互 |

**教训**:
- 调试前先确认使用的是哪个预览模式
- GamePreviewTest 需要手动实现所有脚本执行逻辑

---

### 2. **状态同步是关键**

**问题根源**: React/函数作用域的变量是快照，不会自动更新

**解决原则**:
- ✅ 永远从 store 实时获取最新状态（`getCurrentPage()`, `getState()`）
- ❌ 不要依赖函数参数或闭包中的旧引用

**适用场景**:
- 循环执行多个积木（如 3 个 `motion_followtarget`）
- 需要读取上一次操作的结果
- 任何涉及组件位置、属性的连续操作

**代码模式**:
```typescript
// ❌ 错误：使用快照
const executeBlocks = (blocks, component) => {
  for (const block of blocks) {
    // component.position 永远是初始值
    doSomething(component.position);
    updateComponent(component.id, newData);
  }
}

// ✅ 正确：实时获取
const executeBlocks = (blocks, component) => {
  for (const block of blocks) {
    const fresh = getCurrentPage().components.find(c => c.id === component.id);
    doSomething(fresh.position);  // 使用最新值
    updateComponent(fresh.id, newData);
  }
}
```

---

### 3. **onGameStart vs onUpdate 的使用场景**

| 触发器 | 执行时机 | 执行次数 | 适用场景 | 性能影响 |
|--------|---------|---------|---------|---------|
| **onGameStart** | 场景加载时 | 1次 | 初始化、一次性设置 | 低 |
| **onUpdate** | 每帧 | 持续（60次/秒） | 追踪、AI、物理模拟 | 高 |
| **onClick** | 点击时 | 按需 | 交互响应 | 低 |
| **onKeyDown** | 按键时 | 按需 | 玩家控制 | 低 |
| **onCollision** | 碰撞时 | 按需 | 游戏逻辑 | 中 |

**关键区别**:
- **onGameStart**:
  - ✅ 适合：设置初始位置、加载资源、显示欢迎信息
  - ❌ 不适合：持续移动、追踪、动画

- **onUpdate**:
  - ✅ 适合：敌人追踪、子弹移动、倒计时、AI 决策
  - ❌ 不适合：一次性操作（会重复执行浪费性能）

**AI 生成的常见错误**:
- AI 经常生成 `event_sceneinit` + `logic_forever` + `motion_followtarget`
- 意图是"永久循环执行追踪"，但 `logic_forever` 在同步执行环境中无效
- 正确做法：直接放在 `onUpdate` 中

---

### 4. **触发器检测优先级设计原则**

**设计目标**: 让 AI 生成的任意积木组合都能分配到正确的触发器

**核心原则**:

#### 原则1: 功能导向，而非事件导向
```typescript
// ❌ 错误：按出现顺序检测
if (block.type === 'event_sceneinit') {  // 第1个积木
  triggerKey = 'onGameStart';
  break;  // 后面的 motion_followtarget 被忽略
}

// ✅ 正确：按功能意图检测
if (block.type === 'motion_followtarget') {  // 核心功能
  triggerKey = 'onUpdate';  // 需要持续执行
  break;
}
```

#### 原则2: 持续行为 > 一次性事件
```typescript
优先级排序:
1. motion_followtarget, logic_forever → onUpdate（持续）
2. event_keypress → onKeyDown（按需）
3. event_click → onClick（按需）
4. event_sceneinit → onGameStart（一次）
```

#### 原则3: 多轮检测，逐步降级
```typescript
// 第1轮：检测最关键的功能类型
for (block of blocks) {
  if (isContinuousBehavior(block)) {
    triggerKey = 'onUpdate';
    break;
  }
}

// 第2轮：如果没找到，检查次要类型
if (triggerKey === defaultValue) {
  for (block of blocks) {
    if (isEventTrigger(block)) {
      triggerKey = getEventType(block);
      break;
    }
  }
}
```

#### 原则4: 白名单扩展，不断学习
```typescript
// 持续更新关键词列表
const continuousKeywords = [
  'motion_followtarget',  // 直接的积木类型
  'logic_forever',        // 控制流标志
  'event_timer',          // 时间相关
  '追踪', '跟随',         // 中文关键词
  'follow', 'track',      // 英文关键词
];

// 遇到新的 AI 生成模式时，添加到白名单
```

---

### 5. **调试技巧**

#### 技巧1: 分层日志
```typescript
// 层级1：组件列表（确认场景加载）
console.log('[GamePreviewTest] 📋 场景中的组件列表:');
currentPage.components.forEach((comp, index) => {
  console.log(`  ${index + 1}. "${comp.name}" (类型: ${comp.type}, 角色: ${comp.gameRole?.roleType || '无'})`);
});

// 层级2：脚本执行（确认触发器）
console.log(`[GamePreviewTest] 🎬 执行 ${component.name} 的 onGameStart，${blocks.length} 个积木`);

// 层级3：积木序列（确认逻辑流程）
console.log(`[GamePreviewTest] 📦 ${component.name} 的积木序列:`, blocks.map(b => b.type).join(' → '));

// 层级4：每个积木（确认执行细节）
console.log(`[GamePreviewTest] 🔧 执行积木 [${i}]: ${block.type}`, block.values);

// 层级5：追踪计算（确认移动逻辑）
console.log(`[GamePreviewTest] 🎯 开始追踪计算:`);
console.log(`  - 追踪者: ${comp.name} @ (${comp.position.x}, ${comp.position.y})`);
console.log(`  - 目标: ${target.name} @ (${target.position.x}, ${target.position.y})`);
console.log(`  - 距离: ${distance.toFixed(2)}, 速度: ${speed}`);
```

#### 技巧2: 对比验证
```typescript
// 打印修改前后的值
console.log(`  - 新位置（移动前）: (${newX.toFixed(2)}, ${newY.toFixed(2)})`);
console.log(`  - 新位置（边界限制后）: (${newX.toFixed(2)}, ${newY.toFixed(2)})`);

// 下一次执行时，位置应该不同
```

#### 技巧3: 条件日志（避免刷屏）
```typescript
// 只在特定条件下输出
if (frameCount % 60 === 0) {  // 每60帧（约1秒）输出一次
  console.log(`[GamePreviewTest] 🔄 执行 ${component.name} 的 onUpdate`);
}

// 只在第一次输出
if (!component['_loggedOnce']) {
  console.log('[Debug] 这条消息只输出一次');
  component['_loggedOnce'] = true;
}
```

---

### 6. **常见 AI 生成积木模式**

#### 模式1: 场景初始化 + 永久循环 + 追踪
```json
[
  { "type": "event_sceneinit" },
  { "type": "logic_forever" },
  { "type": "motion_followtarget" }
]
```
**问题**: `logic_forever` 在同步环境中无意义，会导致无限循环卡死
**修复**: 检测到 `motion_followtarget` 或 `logic_forever` → 分配到 `onUpdate`

#### 模式2: 按键判断 + 移动
```json
[
  { "type": "event_keypress", "values": { "key": "KeyW" } },
  { "type": "motion_move", "values": { "direction": "up" } },
  { "type": "event_keypress", "values": { "key": "KeyS" } },
  { "type": "motion_move", "values": { "direction": "down" } }
]
```
**问题**: 多个 `event_keypress` 作为分支条件
**修复**: `event_keypress` 不应触发事件，而是作为条件判断（if-else 逻辑）

#### 模式3: 点击 + 场景跳转
```json
[
  { "type": "event_click" },
  { "type": "state_gotoscene", "values": { "sceneId": "xxx" } }
]
```
**处理**: 检测到 `state_gotoscene` → 分配到 `onClick`

---

### 7. **性能优化建议**

#### 优化1: 按需执行
```typescript
// ❌ 不好：游戏循环一直运行
useEffect(() => {
  const loop = () => {
    executeAllScripts();  // 即使没有脚本也执行
    requestAnimationFrame(loop);
  };
  loop();
}, []);

// ✅ 更好：检查是否有需要执行的脚本
useEffect(() => {
  const hasUpdateScripts = currentPage.components.some(c =>
    c.scripts?.onUpdate && c.scripts.onUpdate.length > 0
  );

  if (!hasUpdateScripts) return;  // 没有脚本则不启动循环

  const loop = () => {
    executeOnUpdateScripts();
    requestAnimationFrame(loop);
  };
  loop();
}, [currentPage]);
```

#### 优化2: 减少日志输出
```typescript
// ❌ 不好：每帧都输出
console.log('[Debug] Frame update');  // 60次/秒

// ✅ 更好：按频率输出
if (frameCount % 60 === 0) {
  console.log('[Debug] Frame update');  // 1次/秒
}

// ✅ 更好：使用概率
if (Math.random() < 0.016) {  // 约 1/60 的概率
  console.log('[Debug] Frame update');
}
```

#### 优化3: 距离阈值
```typescript
// 避免敌人和玩家重叠时抖动
if (distance > 5) {  // 距离大于5才移动
  moveToTarget();
}
```

---

## 完整修改文件列表

### 1. `GamePreviewTest.tsx`
- **第65-85行**: 添加 onGameStart 脚本自动执行
- **第87-185行**: 改造游戏循环为持续运行，添加 onUpdate 脚本执行
- **第150-280行**: 修复 motion_move 积木实时获取组件位置
- **第282-395行**: 实现 motion_followtarget 积木逻辑，实时获取组件位置
- **第193-210行**: 添加详细的调试日志

### 2. `RightSidebar.tsx`
- **第250-310行**: 重构触发器检测逻辑，调整优先级
  - 优先检测持续行为类型（追踪、永久循环）
  - 降低 `event_sceneinit` 的优先级
  - 添加 `logic_forever` 检测

---

## 测试验证步骤

### 步骤1: 重新生成积木
1. 刷新浏览器 (Ctrl + Shift + R)
2. 选择僵尸组件
3. 删除旧的积木（或清空脚本）
4. 使用 AI 生成："让僵尸追踪玩家"
5. **检查控制台**:
   ```
   [RightSidebar] AI生成积木分配到触发器: onUpdate  // ✅ 必须是 onUpdate！
   ```

### 步骤2: 测试预览
1. 打开预览模式
2. **检查控制台**:
   ```
   [GamePreviewTest] 📋 场景中的组件列表:
     1. "虚拟摇杆_xxx" (类型: joystick, 角色: 无)
     2. "法师" (类型: image, 角色: player)
     3. "僵尸" (类型: image, 角色: enemy)

   [GamePreviewTest] 🔄 执行 僵尸 的 onUpdate，1 个积木  // 持续输出
   [GamePreviewTest] 🎯 僵尸 追踪 法师，距离: 150
   ```

3. 使用摇杆移动法师
4. **观察效果**: 僵尸应该持续追踪法师移动 ✅

### 步骤3: 验证状态同步
1. 观察控制台中僵尸的位置变化：
   ```
   - 追踪者: 僵尸 @ (221.15, 290.95)
   - 追踪者: 僵尸 @ (219.82, 255.25)  // ✅ 位置在变化
   - 追踪者: 僵尸 @ (203.50, 266.79)  // ✅ 持续变化
   ```
2. 位置应该每次都不同（说明实时获取生效）

---

## 未来改进方向

### 1. 统一预览架构
- **问题**: GamePreview 和 GamePreviewTest 逻辑重复
- **方案**: 让 GamePreviewTest 也使用 GameEngine，或者废弃其中一个

### 2. AI 提示词优化
- **问题**: AI 生成的积木结构不够理想（包含无用的 `event_sceneinit`）
- **方案**: 改进 AI 的 system prompt，让它直接生成适合 `onUpdate` 的积木

### 3. 触发器可视化
- **问题**: 用户不知道积木被分配到哪个触发器
- **方案**: 在逻辑编辑器中显示触发器标签，允许手动调整

### 4. 性能监控
- **问题**: 大量 `onUpdate` 脚本可能导致卡顿
- **方案**: 添加性能监控，超过阈值时警告用户

---

## 关键教训

### ✅ DO（应该做的）

1. **调试时先确认架构** - 使用的是 GamePreview 还是 GamePreviewTest？
2. **实时获取状态** - 循环中永远从 store 重新查询，不要依赖快照
3. **功能优先于事件** - 检测积木类型时，优先关注功能意图而非事件名称
4. **分层日志** - 从场景 → 组件 → 脚本 → 积木 → 执行细节，逐层深入
5. **向后兼容** - 支持多种触发器键名格式（`onUpdate`, `game_update`, `on-update`）

### ❌ DON'T（不应该做的）

1. **不要依赖函数参数** - `component` 参数是快照，永远不会更新
2. **不要按出现顺序检测** - AI 生成的第一个积木可能是干扰项
3. **不要忽略控制流积木** - `logic_forever` 也需要特殊处理
4. **不要在 onGameStart 中做持续行为** - 只会执行1次
5. **不要在 onUpdate 中做一次性操作** - 会浪费性能

---

## 总结

这次调试暴露了三个层次的问题：

1. **架构层**: GamePreviewTest 缺少自动脚本执行机制
2. **逻辑层**: 状态同步问题导致移动不生效
3. **分配层**: 触发器检测优先级不合理

通过分层解决，最终实现了：
- ✅ AI 生成的追踪积木能正确分配到 `onUpdate`
- ✅ 追踪逻辑能持续每帧执行
- ✅ 状态更新能实时反映到下一次计算

**最大收获**: 在 React 环境中处理游戏循环时，**状态同步**是核心难点。必须明确区分"快照"和"实时查询"，避免使用过期的数据。
